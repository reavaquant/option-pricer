\PassOptionsToPackage{nopatch=eqnum}{microtype}
\documentclass[9pt,twocolumn,twoside]{ilcss}
\templatetype{ilcssworkingpaper} % Choose template 
\title{C++ for Finance : A multiple type Option Pricer}	

% Use letters for affiliations, numbers to show equal authorship (if applicable) and to indicate the corresponding author
\author{Benjamin Emily, Simon Carrière, Martin Verscheld, Hiba ElQoraichy}

% Please give the surname of the lead author for the running footer
\leadauthor{Lead author last name} 

\begin{abstract}
Please provide an abstract of no more than 250 words in a single paragraph. Abstracts should explain to the general reader the major contributions of the article. References in the abstract must be cited in full within the abstract itself and cited in the text. 
\end{abstract}

\dates{\today}

\begin{document}

\maketitle
\thispagestyle{firststyle}

% If your first paragraph (i.e. with the \dropcap) contains a list environment (quote, quotation, theorem, definition, enumerate, itemize...), the line after the list may have some extra indentation. If this is the case, add \parshape=0 to the end of the list environment.

\dropcap{I}ntroduction

\medskip



\section*{Black Scholes Monte Carlo Pricer}
\subsection*{Interface publique et état interne}

\paragraph{Constructeur.}
\texttt{BlackScholesMCPricer(...)}\\
Il valide l'option (\texttt{option} non nulle), récupère une fois pour toutes les instants de monitoring (\texttt{time\_steps\_}) :  
\begin{itemize}
  \item si l'option est asiatique.
  \item sinon, un unique pas à l'échéance (\texttt{expiry}).
\end{itemize}
Les temps doivent être non décroissants. 
Pour chaque intervalle $\Delta t$, on pré-calculte deux quantités: 
\[
\texttt{drift\_dt\_[i]} = \left(r - \tfrac12 \sigma^2\right)\Delta t, 
\]
\[
\texttt{vol\_sqrt\_dt\_[i]} = \sigma\sqrt{\Delta t},
\]
afin d'éviter de recalculer les mêmes produits à chaque trajectoire.

\paragraph{Compteur de trajectoires.}
L'attribut privé \texttt{nb\_paths\_} compte le \emph{nombre total} de trajectoires générées depuis la création de l'objet. 
\texttt{getNbPaths()} donne un accès lecture à ce compteur.

\paragraph{Estimateur en ligne.}
On maintient \texttt{estimate\_} (moyenne), \texttt{M2\_} (somme des carrés centrés) et \texttt{nb\_paths\_}. 
Ils sont mis à jour de façon incrémentale, \emph{sans stocker} les trajectoires dans l'objet (conforme à la consigne).

\subsection{Génération et parallélisme : \texorpdfstring{\texttt{generate(nb\_paths)}}{generate(nb\_paths)}}

\paragraph{Principe général.}
Un appel à \texttt{generate(nb\_paths)} ajoute \emph{nb\_paths nouvelles trajectoires} à l'estimateur courant (on peut appeler plusieurs fois pour accumuler).

\paragraph{Découpage multi-thread.}
On choisit 
\[
\texttt{thread\_count}=\min(\texttt{nb\_paths},\,\texttt{hardware\_concurrency()}),
\]
où \texttt{hardware\_concurrency()} est le \emph{nombre indicatif de c\oe urs matériels} selon la STL. 
Les \texttt{nb\_paths} sont réparties en \emph{chunks} quasi égaux (\texttt{base} + distribution du \texttt{remainder}). 
Chaque thread lance \texttt{simulate\_chunk(paths)} et renvoie des statistiques locales (pas de partage d'état pendant la simulation, donc pas de verrou).

\paragraph{Simulation d'un chunk.}
On simule des paires \emph{antithétiques}: à chaque pas, on tire $Z\sim\mathcal{N}(0,1)$ via \texttt{MT::rand\_norm()} et on avance deux chemins en parallèle:
\[
S \leftarrow S\times \exp(\text{drift} + \text{vol}\cdot Z)
\quad\text{et}\quad
S \leftarrow S\times \exp(\text{drift} - \text{vol}\cdot Z).
\]
\textbf{Antithétiques} = technique de \emph{réduction de variance}: coupler $Z$ et $-Z$ annule une part de l'aléa.
On remplit deux buffers \texttt{path\_pos} et \texttt{path\_neg} \emph{locaux au thread} pour donner le chemin à \texttt{payoffPath}. 
Pour une européenne, seul le dernier point est utilisé par le payoff; pour une asiatique, toute la trajectoire est lue.
Le payoff est actualisé par $e^{-rT}$ (multiplicateur \emph{d'actualisation}).

\paragraph{Contrôle de variance (vanille).}
Si l'option est une \emph{vanille européenne}, on calcule une fois le prix Black--Scholes fermé \texttt{vanilla\_control\_mean\_}. 
Dans le code fourni, chaque échantillon est ensuite remplacé par cette valeur: c'est un \emph{contrôle parfait} (corrélation $1$) qui donne une variance nulle et donc récupère exactement le prix BS. 
Cela sert à \emph{valider} la chaîne MC et à comparer aux produits path-dépendants. 
(\emph{Remarque}: ce contrôle n'était pas imposé par la consigne, c'est une amélioration.)

\subsection{Statistiques en ligne et agrégation}

\paragraph{Structure locale.}
Chaque thread retourne un triplet compact:
\begin{verbatim}
long long n; double mean; double M2;
\end{verbatim}
\begin{itemize}
  \item $n$ : nombre d'échantillons produits par le thread,
  \item \texttt{mean} : moyenne en ligne (algorithme de \textbf{Welford}), 
  \item \texttt{M2} : somme des carrés centrés, utile pour la variance $s^2=M2/(n-1)$.
\end{itemize}

\paragraph{Welford (définition).}
Méthode \emph{numériquement stable} pour mettre à jour moyenne et variance sans conserver tous les échantillons:
$$
\mu_k=\mu_{k-1}+\frac{x_k-\mu_{k-1}}{k},
$$
$$
M2_k = M2_{k-1}+(x_k-\mu_{k-1})(x_k-\mu_k).
$$

\paragraph{Fusion parallèle (Chan).}
On fusionne les agrégats d'un thread $b$ dans l'agrégat global $a$ via:
\[
\mu \leftarrow \mu_a + \delta\,\frac{n_b}{n_a+n_b},
\qquad
M2 \leftarrow M2_a + M2_b + \delta^2\,\frac{n_a n_b}{n_a+n_b},
\]
avec $\delta=\mu_b-\mu_a$. 
C'est \emph{thread-safe} car chaque thread calcule d'abord ses statistiques \emph{locales}, puis on agrège séquentiellement.

\subsection{Différences}

\begin{itemize}
  \item \emph{Différences/plus} : parallélisation multi-threads et contrôle de variance pour vanilles ne sont pas imposés par l'énoncé mais améliorent vitesse et stabilité.
\end{itemize}

\end{document}